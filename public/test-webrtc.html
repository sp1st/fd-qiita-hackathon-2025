<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC通話テスト</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f0f0f0;
    }
    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }
    .video-container {
      background: #000;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      aspect-ratio: 16/9;
    }
    video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .label {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 14px;
    }
    .controls {
      margin-top: 20px;
      display: flex;
      gap: 10px;
      justify-content: center;
    }
    button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: white;
      cursor: pointer;
      font-size: 16px;
    }
    button:hover {
      background: #0056b3;
    }
    button:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }
    .status {
      text-align: center;
      margin: 20px 0;
      padding: 10px;
      background: white;
      border-radius: 4px;
    }
    #logs {
      margin-top: 20px;
      padding: 10px;
      background: white;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <h1>WebRTC P2P通話テスト</h1>

  <div class="status">
    <p>セッションID: <input type="text" id="sessionId" value="test-session-001" style="width: 200px;"></p>
    <p>ユーザーID: <input type="text" id="userId" value="" placeholder="自動生成" style="width: 200px;"></p>
    <p>接続状態: <span id="connectionStatus">未接続</span></p>
  </div>

  <div class="container">
    <div class="video-container">
      <video id="localVideo" autoplay muted playsinline></video>
      <div class="label">自分</div>
    </div>
    <div class="video-container">
      <video id="remoteVideo" autoplay playsinline></video>
      <div class="label">相手</div>
    </div>
  </div>

  <div class="controls">
    <button id="startBtn">開始</button>
    <button id="callBtn" disabled>通話開始</button>
    <button id="hangupBtn" disabled>切断</button>
    <button id="muteBtn" disabled>ミュート</button>
    <button id="turnTestBtn">TURNテスト</button>
  </div>

  <div id="logs"></div>

  <script>
    // グローバル変数
    let localStream = null;
    let peerConnection = null;
    let websocket = null;
    let sessionId = '';
    let userId = '';
    let isInitiator = false;

    // 要素の取得
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const startBtn = document.getElementById('startBtn');
    const callBtn = document.getElementById('callBtn');
    const hangupBtn = document.getElementById('hangupBtn');
    const muteBtn = document.getElementById('muteBtn');
    const connectionStatus = document.getElementById('connectionStatus');
    const logsDiv = document.getElementById('logs');

    // ログ関数
    function log(message) {
      const time = new Date().toLocaleTimeString();
      logsDiv.innerHTML += `${time}: ${message}<br>`;
      logsDiv.scrollTop = logsDiv.scrollHeight;
      console.log(message);
    }

    // 開始ボタン
    startBtn.onclick = async () => {
      sessionId = document.getElementById('sessionId').value;
      userId = document.getElementById('userId').value || 'user-' + Math.random().toString(36).substr(2, 9);
      document.getElementById('userId').value = userId;

      try {
        // カメラ・マイクのアクセス
        log('カメラ・マイクにアクセス中...');
        localStream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: true
        });
        localVideo.srcObject = localStream;
        log('ローカルストリーム取得成功');

        // WebSocket接続
        connectWebSocket();

        startBtn.disabled = true;
        callBtn.disabled = false;
      } catch (error) {
        log('エラー: ' + error.message);
      }
    };

    // WebSocket接続
    function connectWebSocket() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      // 統合構成でのWebSocket接続
      const wsUrl = `${protocol}//${window.location.host}/api/ws/simple/${sessionId}?userId=${userId}`;

      log('WebSocket接続中: ' + wsUrl);
      websocket = new WebSocket(wsUrl);

      websocket.onopen = () => {
        log('WebSocket接続成功');
        connectionStatus.textContent = 'WebSocket接続済み';
      };

      websocket.onmessage = async (event) => {
        const message = JSON.parse(event.data);
        log('受信: ' + message.type + ' from ' + message.userId);

        if (message.userId === userId) return; // 自分のメッセージは無視

        switch (message.type) {
          case 'join':
            log('新しい参加者: ' + message.userId);
            if (isInitiator) {
              // 既存の参加者が新規参加者にオファーを送る
              await createOffer();
            }
            break;

          case 'offer':
            if (!isInitiator) {
              await handleOffer(message.data);
            }
            break;

          case 'answer':
            if (isInitiator) {
              await handleAnswer(message.data);
            }
            break;

          case 'ice-candidate':
            await handleIceCandidate(message.data);
            break;

          case 'leave':
            log('参加者が退出: ' + message.userId);
            hangup();
            break;
        }
      };

      websocket.onerror = (error) => {
        log('WebSocketエラー: ' + error);
      };

      websocket.onclose = () => {
        log('WebSocket切断');
        connectionStatus.textContent = 'WebSocket切断';
      };
    }

    // 通話開始
    callBtn.onclick = async () => {
      isInitiator = true;
      await createPeerConnection();
      await createOffer();

      callBtn.disabled = true;
      hangupBtn.disabled = false;
      muteBtn.disabled = false;
    };

    // PeerConnection作成
    async function createPeerConnection() {
      log('PeerConnection作成中...');

      // デフォルトのSTUNサーバー
      let iceServers = [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun.cloudflare.com:3478' }
      ];

      // TURN認証情報を取得
      console.log('[TURN] Fetching credentials...');
      log('TURN認証情報を取得中...');
      
      try {
        const response = await fetch('/api/turn-credentials');
        console.log('[TURN] API response status:', response.status);
        
        if (response.ok) {
          const data = await response.json();
          console.log('[TURN] API response data:', data);
          
          if (data.iceServers && data.iceServers.length > 0) {
            iceServers = data.iceServers;
            console.log('[TURN] Using', data.iceServers.length, 'ICE servers from API');
            log(`Cloudflare TURN認証情報を取得しました: ${data.iceServers.length}個のサーバー`);
            
            // TURNサーバーの詳細をログ
            data.iceServers.forEach((server, index) => {
              if (server.urls && server.username) {
                console.log(`[TURN] Server ${index} has credentials:`, server.urls);
              }
            });
          } else {
            console.log('[TURN] No ICE servers in response');
            log('TURN認証情報が空です');
          }
        } else {
          console.log('[TURN] API error:', response.status);
          log(`TURN APIエラー: ${response.status}`);
        }
      } catch (error) {
        console.error('[TURN] Fetch error:', error);
        log('TURN認証情報の取得エラー: ' + error.message);
      }

      const configuration = {
        iceServers,
        iceCandidatePoolSize: 10,
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require'
      };

      console.log('[TURN] Final ICE configuration:', JSON.stringify(configuration, null, 2));

      peerConnection = new RTCPeerConnection(configuration);
      
      console.log('[TURN] PeerConnection created successfully');

      // ローカルストリームのトラックを追加
      localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
      });

      // リモートストリーム受信
      peerConnection.ontrack = (event) => {
        log('リモートトラック受信');
        if (remoteVideo.srcObject !== event.streams[0]) {
          remoteVideo.srcObject = event.streams[0];
        }
      };

      // ICE候補
      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          log('ICE候補送信');
          sendMessage({
            type: 'ice-candidate',
            data: event.candidate
          });
        }
      };

      // ICE収集状態
      peerConnection.onicegatheringstatechange = () => {
        log('ICE収集状態: ' + peerConnection.iceGatheringState);
      };

      // ICE接続状態
      peerConnection.oniceconnectionstatechange = async () => {
        log('ICE接続状態: ' + peerConnection.iceConnectionState);
        
        // 接続失敗時の詳細情報を取得
        if (peerConnection.iceConnectionState === 'failed' || peerConnection.iceConnectionState === 'disconnected') {
          const stats = await peerConnection.getStats();
          let hasRelayCandidates = false;
          stats.forEach(report => {
            if (report.type === 'candidate-pair' && report.state === 'failed') {
              log(`失敗したICE候補ペア: ${report.localCandidateId} <-> ${report.remoteCandidateId}`);
            }
            if (report.type === 'transport') {
              log(`トランスポート状態: ${report.iceState}, 選択されたペア: ${report.selectedCandidatePairId}`);
            }
            if (report.type === 'local-candidate' && report.candidateType === 'relay') {
              hasRelayCandidates = true;
            }
          });
          
          if (!hasRelayCandidates) {
            log('警告: TURNサーバー経由の候補が見つかりません。携帯回線では接続できない可能性があります。');
          }
        }
      };

      // 接続状態
      peerConnection.onconnectionstatechange = () => {
        log('接続状態: ' + peerConnection.connectionState);
        connectionStatus.textContent = 'P2P: ' + peerConnection.connectionState;
      };

      log('PeerConnection作成完了');
    }

    // オファー作成
    async function createOffer() {
      if (!peerConnection) {
        await createPeerConnection();
      }

      log('オファー作成中...');
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      sendMessage({
        type: 'offer',
        data: offer
      });
      log('オファー送信完了');
    }

    // オファー処理
    async function handleOffer(offer) {
      if (!peerConnection) {
        await createPeerConnection();
      }

      log('オファー受信・処理中...');
      await peerConnection.setRemoteDescription(offer);

      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);

      sendMessage({
        type: 'answer',
        data: answer
      });
      log('アンサー送信完了');

      hangupBtn.disabled = false;
      muteBtn.disabled = false;
    }

    // アンサー処理
    async function handleAnswer(answer) {
      log('アンサー受信・処理中...');
      await peerConnection.setRemoteDescription(answer);
      log('アンサー処理完了');
    }

    // ICE候補処理
    async function handleIceCandidate(candidate) {
      log('ICE候補受信');
      try {
        await peerConnection.addIceCandidate(candidate);
      } catch (error) {
        log('ICE候補追加エラー: ' + error.message);
      }
    }

    // メッセージ送信
    function sendMessage(message) {
      if (websocket && websocket.readyState === WebSocket.OPEN) {
        websocket.send(JSON.stringify({
          ...message,
          userId: userId
        }));
      }
    }

    // 切断
    hangupBtn.onclick = () => {
      hangup();
      sendMessage({ type: 'leave' });
    };

    function hangup() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }

      if (remoteVideo.srcObject) {
        remoteVideo.srcObject.getTracks().forEach(track => track.stop());
        remoteVideo.srcObject = null;
      }

      callBtn.disabled = false;
      hangupBtn.disabled = true;
      muteBtn.disabled = true;
      isInitiator = false;

      connectionStatus.textContent = 'P2P切断';
      log('通話終了');
    }

    // ミュート
    let isMuted = false;
    muteBtn.onclick = () => {
      isMuted = !isMuted;
      localStream.getAudioTracks().forEach(track => {
        track.enabled = !isMuted;
      });
      muteBtn.textContent = isMuted ? 'ミュート解除' : 'ミュート';
      log(isMuted ? 'ミュート' : 'ミュート解除');
    };

    // TURNテストボタン
    const turnTestBtn = document.getElementById('turnTestBtn');
    turnTestBtn.onclick = async () => {
      log('TURN接続テスト開始...');
      console.log('[TURN TEST] Starting TURN connection test...');
      
      try {
        // TURN APIをテスト
        const response = await fetch('/api/turn-credentials');
        console.log('[TURN TEST] API Response status:', response.status);
        log(`TURN API応答: ${response.status}`);
        
        if (!response.ok) {
          throw new Error(`APIエラー: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('[TURN TEST] Received data:', data);
        log(`TURNサーバー数: ${data.iceServers?.length || 0}`);
        
        // TURNサーバー情報を表示
        if (data.iceServers) {
          data.iceServers.forEach((server, index) => {
            if (server.urls) {
              const urls = Array.isArray(server.urls) ? server.urls : [server.urls];
              urls.forEach(url => {
                if (url.includes('turn:')) {
                  log(`TURNサーバー[${index}]: ${url}`);
                  if (server.username) {
                    log(`  - ユーザー名: ${server.username.substring(0, 16)}...`);
                    log(`  - 認証情報: あり`);
                  }
                } else if (url.includes('stun:')) {
                  log(`STUNサーバー[${index}]: ${url}`);
                }
              });
            }
          });
        }
        
        // テスト用PeerConnectionを作成
        log('TURNサーバーでテストPeerConnection作成...');
        const testPc = new RTCPeerConnection({
          iceServers: data.iceServers || []
        });
        
        // ICE候補を収集
        testPc.onicecandidate = (event) => {
          if (event.candidate) {
            const candidate = event.candidate;
            console.log('[TURN TEST] ICE Candidate:', candidate);
            
            if (candidate.type === 'relay') {
              log(`✅ TURN経由のICE候補を検出: ${candidate.address}`);
            } else {
              log(`ICE候補 (${candidate.type}): ${candidate.address}`);
            }
          }
        };
        
        // ダミーのオファーを作成してICE収集を開始
        const offer = await testPc.createOffer();
        await testPc.setLocalDescription(offer);
        
        // 5秒待ってから結果を確認
        setTimeout(() => {
          testPc.close();
          log('TURN接続テスト完了');
        }, 5000);
        
      } catch (error) {
        console.error('[TURN TEST] Error:', error);
        log(`TURNテストエラー: ${error.message}`);
      }
    };
  </script>
</body>
</html>
